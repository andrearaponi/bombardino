# Request Chaining

Request chaining lets you use data from one request in another. This is essential for testing real API workflows like:

- Create a user, then get their profile
- Login, then access protected endpoints
- Create an order, then check its status

## The Problem

Imagine testing a CRUD API:

1. **Create** a person → API returns `{"id": 42, "name": "Mario"}`
2. **Read** that person → Need to call `/api/persons/42`
3. **Delete** that person → Need to call `/api/persons/42`

The ID (`42`) is generated by the server. You can't know it in advance. That's where extraction and variables come in.

## Variables: The `${variable}` Syntax

Bombardino uses `${variable_name}` to reference values:

```json
"path": "/api/persons/${person_id}"
```

When the test runs, `${person_id}` is replaced with the actual value.

## Extraction: Getting Values from Responses

Use the `extract` field to pull values from a response:

```json
{
  "name": "Create Person",
  "method": "POST",
  "path": "/api/persons",
  "body": {
    "name": "Mario",
    "surname": "Rossi"
  },
  "extract": [
    {"name": "person_id", "source": "body", "path": "id"},
    {"name": "person_email", "source": "body", "path": "mail"}
  ]
}
```

This extracts:
- `person_id` from the response body's `id` field
- `person_email` from the response body's `mail` field

### Extraction Options

| Field | Description |
|-------|-------------|
| `name` | Variable name to store the value |
| `source` | Where to get the value: `body`, `header`, or `status` |
| `path` | For `body`: JSON path to the field. For `header`: header name |

**Extract from body (JSON):**
```json
{"name": "user_id", "source": "body", "path": "id"}
{"name": "token", "source": "body", "path": "auth.token"}
{"name": "first_item", "source": "body", "path": "items.0.name"}
```

**Extract from header:**
```json
{"name": "location", "source": "header", "path": "Location"}
{"name": "request_id", "source": "header", "path": "X-Request-ID"}
```

**Extract status code:**
```json
{"name": "status", "source": "status", "path": ""}
```

## Dependencies: `depends_on`

By default, Bombardino runs tests in parallel for maximum speed. But sometimes tests must run in order. Use `depends_on` to specify which tests must complete first:

```json
{
  "name": "Get Person",
  "path": "/api/persons/${person_id}",
  "depends_on": ["Create Person"]
}
```

This ensures:
1. "Create Person" runs first
2. Its extracted values are available
3. "Get Person" runs after

### Execution Order

Bombardino uses a DAG (Directed Acyclic Graph) to determine execution order:

```
Phase 1: Tests with no dependencies (run in parallel)
    ↓
Phase 2: Tests depending on Phase 1 (run in parallel)
    ↓
Phase 3: Tests depending on Phase 2 (run in parallel)
    ...
```

**Example:**

```json
"tests": [
  {"name": "A", "depends_on": []},           // Phase 1
  {"name": "B", "depends_on": []},           // Phase 1
  {"name": "C", "depends_on": ["A"]},        // Phase 2
  {"name": "D", "depends_on": ["A", "B"]},   // Phase 2
  {"name": "E", "depends_on": ["C", "D"]}    // Phase 3
]
```

Execution:
- Phase 1: A and B run in parallel
- Phase 2: C and D run in parallel (after A and B complete)
- Phase 3: E runs (after C and D complete)

## Complete Example: CRUD Workflow

Here's a full CRUD test using extraction and dependencies:

```json
{
  "name": "Person CRUD Test",
  "global": {
    "base_url": "http://localhost:8080",
    "iterations": 1,
    "headers": {
      "Content-Type": "application/json"
    }
  },
  "tests": [
    {
      "name": "Create Person",
      "method": "POST",
      "path": "/api/persons",
      "expected_status": [201],
      "body": {
        "name": "Mario",
        "surname": "Rossi",
        "age": 30,
        "mail": "mario@test.com"
      },
      "extract": [
        {"name": "person_id", "source": "body", "path": "id"},
        {"name": "person_email", "source": "body", "path": "mail"}
      ]
    },
    {
      "name": "Get Person by ID",
      "method": "GET",
      "path": "/api/persons/${person_id}",
      "expected_status": [200],
      "depends_on": ["Create Person"],
      "assertions": [
        {
          "type": "json_path",
          "target": "name",
          "operator": "eq",
          "value": "Mario"
        }
      ]
    },
    {
      "name": "Get Person by Email",
      "method": "GET",
      "path": "/api/persons/by-mail?mail=${person_email}",
      "expected_status": [200],
      "depends_on": ["Create Person"]
    },
    {
      "name": "Update Person",
      "method": "PUT",
      "path": "/api/persons/${person_id}",
      "expected_status": [200],
      "depends_on": ["Get Person by ID"],
      "body": {
        "name": "Mario",
        "surname": "Rossi-Updated",
        "age": 31,
        "mail": "mario@test.com"
      }
    },
    {
      "name": "Delete Person",
      "method": "DELETE",
      "path": "/api/persons/${person_id}",
      "expected_status": [204],
      "depends_on": ["Update Person"]
    },
    {
      "name": "Verify Deletion",
      "method": "GET",
      "path": "/api/persons/${person_id}",
      "expected_status": [404],
      "depends_on": ["Delete Person"]
    }
  ]
}
```

**Execution order:**
1. Create Person (extracts `person_id` and `person_email`)
2. Get Person by ID + Get Person by Email (parallel, both use `person_id`)
3. Update Person
4. Delete Person
5. Verify Deletion (expects 404)

## Using Variables in Different Places

Variables can be used in:

**Path:**
```json
"path": "/api/persons/${person_id}"
```

**Query string:**
```json
"path": "/api/search?email=${email}&status=${status}"
```

**Body:**
```json
"body": {
  "user_id": "${user_id}",
  "message": "Hello, ${user_name}!"
}
```

**Headers:**
```json
"headers": {
  "Authorization": "Bearer ${auth_token}"
}
```

## Tips

1. **Use meaningful variable names**: `person_id` is better than `id`
2. **Check dependencies exist**: Misspelled test names cause errors
3. **Avoid circular dependencies**: A depends on B, B depends on A = error
4. **Remember iterations**: With `iterations > 1`, each iteration is independent

## Debugging Variables

Use `-verbose` to see variable extraction:

```bash
bombardino -config test.json -verbose
```

Output shows:
```
[12:34:56] [a1b2c3d4] EXTRACT person_id = 42
[12:34:56] [a1b2c3d4] EXTRACT person_email = mario@test.com
```

## Next Steps

- [Think Time](think-time.md) - Add realistic delays between requests
- [Data-Driven Testing](data-driven-testing.md) - Use variables with different data sets
- [Tutorial: CRUD API](tutorial-crud-api.md) - Complete walkthrough
